\ifx\all\undefined
\include{0.base}
\begin{document}
\fi
\chapter{Interacciones entre Aspectos}

En el capítulo anterior se describieron detalles de diseño e implementación \textit{AO} del \textit{software} para una \sm.
Como fue descripto en el capítulo 2, entre los aspectos generan interacciones, las cuales son el objeto de estudio de este trabajo. 
Ejemplos de las mismas se pueden encontrar entre los \cns~ descriptos anteriormente. 

Existe un conflicto
entre \demo~ y \meters, dado que los \textit{meters} no deben ser alterados en modo \textit{demo}.\newline
Una interacción de tipo \textit{Mutex} se da cuando dos o más \comms, que proveen la misma funcionalidad, están activos al mismo tiempo. \\
Existe una interacción de tipo \textit{dependency} entre los \comms~ y el \cn~ de \meters, por el hecho de que estos deben ser reportados
por los protocolos. \newline
Por último una interacción de tipo \textit{reinforcement} se da cuando una \sm~ tiene la capacidad de detectar \errors. Estás son utilizadas
por los \comms~para ser reportadas en tiempo real, ampliando la funcionalidad de los protocolos.

En este capítulo se detallan los mecanismos desarrollados para el tratamiento estas interacciones. Los mismos permiten lograr el comportamiento
deseado para el \textit{software} de una \sm.\newline
Sobre el final, se presenta un análisis de los mecanismos desarrollados. En el mismo se discuten
ventajas y desventajas en lo referido a generalización, modularización, escalabilidad y otros factores de la Ingeniería de \textit{Software}.

\section{Interacciones identificadas en el dominio de las SM }
\label{slots:sec:interactions}

A partir del estudio de los requerimientos y considerando la taxonomía de interacciones de \textit{Sanen et al.} \cite{Sanen06},
las relaciones \textit{crosscutting} e interacciones que se dan entre los \cns~ del dominio, se muestran mediante una notación \textit{ad-hoc} en la figura \ref{fig:interactions2}.
Este gráfico completa el presentado en \ref{slots:sec:relations}, donde se indicaron las relaciones entre los \cns.\newline
Esta es una selección de las interacciones más representativas, hay otras que no fueron incluídas en la figura para evitar sobrecargar el gráfico.

\begin{figure}[h]
   \centering \epsfig{file=img/5/interactions2, width=14cm}
   \caption{Relaciones e interacciones entre los \cns~del dominio.}
   \label{fig:interactions2}
\end{figure}

En esta figura el \textit{base} \cn~ de \game~ es representado por un rectángulo, mientras que los \ccc~ son representados por óvalos.
Las relaciones de \textit{crosscuts} se indican con líneas s\'olidas, mientras que las interacciones están representas por líneas punteadas.
Las interacciones de la figura \ref{fig:interactions2} son las siguientes:

\begin{enumerate}

\item[1.] \textbf{Conflict} entre \textit{Demo} y \textit{Program
Resumption}:  dado que los datos alterados en modo \demo~ no deben ser persistidos.

\item[2.] \textbf{Conflict} entre \textit{Demo} y \textit{G2S}: se genera por el hecho que ambos \cns~ no pueden estar
activos al mismo tiempo, dado que uno de los requerimientos del modo \textit{demo} es que los eventos no sean reportados a los protocolos de comunicaci\'on.

\item[3.] \textbf{Dependency} de \textit{G2S} y \textit{PCP} sobre \textit{Meters}: 
una de las características de los protocolos de comunicaci\'on es que deben reportar el estado de los \textit{meters}. 
Para esto dependen del correcto funcionamiento del \cn~ de \meters~ para enviar datos válidos.

\item[4.]\textbf{Mutex} entre \textit{G2S} y \textit{PCP}: esta interacción se genera porque ambos protocolos implementan una
misma funcionalidad. Por ejemplo, con ambos protocolos activos, de recibirse un comando que cambia la hora de la \sm~ de manera
remota, podrían producirse inconsistencias en los datos guardados por la \sm.

\item[5.] \textbf{Reinforcement} de \textit{G2S} con \textit{Error Conditions}: dado que el requerimiento 
de reportar las \errors~ no es obligatorio, se da una interacción de tipo \textit{reinforcement} cuando
estos datos están disponibles y pueden ser utilizados por los protocolos para el reporte de los mismos en tiempo real.


\end{enumerate}

En las próximas secciones se explican los mecanismos desarrollados para el tratamiento de las siguientes interacciones:
% Basados en la clasificación de \textit{Sanen et al.} \cite{Sanen06}, las interacciones del dominio que se estudian son:
\begin{itemize}
\item Tipo \textbf{Mutex}: entre los \comm~ \textit{G2S} y \textit{PCP}.
\item Tipo \textbf{Conflict}: entre \demo~ y: \comms, \resump, \recall~ y \meters.
\item Tipo \textbf{Dependency}: \comms~sobre \meters.
\item Tipo \textbf{Reinforcement}: \error~ a \comms.
\end{itemize}

\section{Mutex}

Esta forma de interacción trata la exclusión mútua entre aspectos, la cual se
presenta si dos aspectos brindan una misma funcionalidad. Ante este 
caso, es necesario asegurar que sólo se utilice uno de los aspectos a la vez. De no
tratar esta interacción, la ejecución de ambos aspectos, puede generar un comportamiento
no deseado en el sistema.

El \textit{software} de las \sm~ puede tener activo más de un protocolo a la vez.
Como se explicó en la sección \ref{domain:comm}, los diferentes protocolos implementan funcionalidad similar.
Estas operaciones se pueden dividir en dos grupos: por un lado las que obtienen datos 
de la \sm~ y por otro lado, las que configuran su estado. La ejecución
de estas últimas, en protocolos diferentes, puede ser la causa
de errores e inconsistencias. Ejemplos concretos de operaciones que pueden generar estos problemas son:

\begin{description}
\item [\textbf{Set time:}] este comando permite configurar de manera remota la hora de una \sm~ y es enviado
periódicamente por los sistemas de monitoreo, utilizando diferentes protocolos.
En ciertas ocasiones, puede darse el caso de que los servidores que envían los comandos no estén sincronizados.
Si la \sm~ está utilizando más de un protocolo a la vez, puede generarse información 
inconsistente. Por ejemplo, el listado de \textit{game recall}, podría tener eventos desordenados en el tiempo.

\item [\textbf{Set progressive:}]
muchos juegos cuentan con una característica llamada ``pozo acumulado'' (progressive). 
Esta funcionalidad permite que un grupo de \sm s, aporten un porcentaje de las apuestas a 
un pozo común, pudiendo cualquiera de ellas pagar el pozo acumulado como premio mayor.\\
Para la implementación de esta característica, también son utilizados los protocolos de comunicación. Si 
se utiliza más de un protocolo a la vez, se pueden generar varios problemas.
Un ejemplo es el valor del pozo por el que una \sm~ participa, el cual se
muestra en un \textit{display} de \textit{leds} sobre el gabinete.
Dicho valor es recibido frecuentemente via los 
protocolos, dado que varía con el aporte de cada juego.
De recibir el valor del pozo de diferentes protocolos, la \sm~estaría mostrando al usuario información incorrecta.
\end{description}

Como se detalló en el capítulo anterior, la funcionalidad de los protocolos \textit{G2S} y \textit{PCP}
se implementó con aspectos. La operaciones como \textit{set time} y \textit{set progressive} generan 
una interacción de tipo \textit{Mutex}.

\subsection{Implementación de la Interacción}

Como fue explicado, ejecutar operaciones que alteren el estado de la \sm~ desde 
protocolos diferentes puede ser la causa de errores o inconsistencias. Una opción para tratar
este problema, es asignarle permiso a un protocolo para realizar este tipo de operaciones.
Desafortunadamente, esto resulta ser una solución demasiado global para los requerimientos de nuestro sistema, 
dado que es necesario que distintos ítems de configuración sean modificados por diferentes protocolos. Por ejemplo, si el protocolo 
\textit{PCP} obtiene el permiso para ejecutar el comando \textit{set time},
esto no debe implicar que la obtenga para el resto de las operaciones.

Por lo tanto, es necesario que la solución brinde un nivel de granularidad
más fino, que permita controlar la exclusión mútua \textbf{por operación}.
La solución que se propone para lograr esto consiste en:

\begin{enumerate}
 \item Identificar el \textit{joint point} (operación), que al ser ejecutado desde protocolos diferentes, produce el conflicto.
 \item Capturar dicha ejecución mediante un \textit{around advice}.
 \item Evaluar una regla en dicho \textit{advice}, para decidir si proceder o no, con la ejecución del método.
\end{enumerate}

La figura~\ref{fig:imp_mutex1} muestra los módulos que componen el mecanismo propuesto.
Se definió una jerarquía de aspectos \texttt{Mutex}, que tiene como colaborador un objeto \texttt{LockType}, que implementa
el patrón de diseño \textit{Strategy} \cite{Gamma:1995}.
Este último, especifica una regla particular, la cual permite determinar si un objeto puede obtener el \textit{lock}.

El aspecto abstracto \texttt{Mutex} define un \textit{around advice}, el cual es asociado al
\textit{abstract pointcut} \texttt{tryLock()}. En dicho \textit{advice} se eval\'ua la regla definida en el objeto 
\texttt{LockType} asociado. Por cada caso donde sea necesario un \textit{mutex}, se subclasificará el aspecto 
definiendo un \textit{pointcut} concreto.

\begin{figure}[ht!]
\centering
\includegraphics[width=5.1in]{img/5/mutex/clases1.eps}
\caption{Clases abstractas del mecanismo.}
\label{fig:imp_mutex1}
\end{figure}

\FloatBarrier
La implementación del aspecto abstracto \texttt{Mutex} se puede ver en el fragmento de código \ref{fig:mutex_code1}.
En la línea 3 se define la variable \texttt{\_lock} que contendrá la instancia de \texttt{LockType}. Luego, en la 
línea 4 se declara un \textit{abstract pointcut} al cual se asocia el \textit{around advice} definido
entre las líneas 6 y 10. En el cuerpo del mismo se delega en el objeto \texttt{LockType} la decisión respecto de
si proceder o no con la ejecución del método.

\begin{lstlisting}[label=fig:mutex_code1,caption={Código genérico de la clase \texttt{Mutex}.}]
public abstract aspect Mutex {

  private LockType _lock;
  protected abstract pointcut tryLock( Object s );
  ...
  void around( Object s ) : tryLock(s) {
      if (_lock != null && _lock.tryLock( s )) {
	  proceed( s );
      }  
  }
}  
\end{lstlisting}

Por otra parte, las subclases de la jerarquía \texttt{LockType} deben implementar el método 
\texttt{tryLock( Object o )}. Como se ejemplifica más adelante, cada subclase implementa un lógica particular.
De esta manera
una instancia de esta jerarquía será usada como se vio en el listado de código \ref{fig:mutex_code1}, 
para determinar si proceder o no con la ejecución del método.

Para instanciar el mecanismo, el programador necesita subclasificar el aspecto \texttt{Mutex}
y realizar dos acciones:

\begin{enumerate}
\item Definir el \textit{pointcut} que captura el \textit{join point} generador del conflicto
y que necesita ser controlado por un \textit{mutex}.
\item Instanciar el \texttt{LockType} deseado.
\end{enumerate}

A continuación, se detalla como este mecanismo genérico, fue instanciado para resolver el 
conflicto de la operación \textit{SetTime}.

\subsection{Instanciación del mecanismo para el comando Set Time}

Para resolver este conflicto, fueron subclasificados el aspecto \texttt{Mutex} y la clase \texttt{LockType},
como se puede ver en la figura \ref{fig:sec_mutex2}.
La estrategia de \textit{locking} elegida para tratar el conflicto de la operación \textit{set time} se denominó
\texttt{FirstLockerKeepsLock}. La misma define que sólo el primer objeto en capturar el \textit{lock} puede volver a obtenerlo.

\begin{figure}[ht!]
\centering
\includegraphics[width=5.1in]{img/5/mutex/clases2.eps}
\caption{Instanciación del mecanismo para el comando \textit{SetTime}.}
\label{fig:sec_mutex2}
\end{figure}

El fragmento de código \ref{fig:mutex_code2} muestra la implementación del método 
\texttt{tryLock()} de la clase \texttt{FirstLockerKeepsLock}. La primera vez que un objeto
adquiere el \textit{lock}, pasa a ser el dueño del \textit{mutex} (línea 7).
En las próximas capturas de \textit{join points}, se compara la identidad de los objetos para determinar si quien 
intenta obtener el \textit{lock} es el dueño.

% Realizar la comparación a nivel de objeto, 
% hace de esta una estrategia completamente reusable.

\begin{lstlisting}[label=fig:mutex_code2,caption={Método \texttt{tryLock} de la clase \texttt{FirstLockerKeepsLock}.}]
@Override
public boolean tryLock( Object o ) {
  synchronized (lock()) {
      if (_owner != null) {
	  return (_owner.equals( o ));
      }
      _owner = o;
  }
  return true;
}
\end{lstlisting}

Definida la estrategia a utilizar, se definió el aspecto \texttt{SetTime} que hereda de \texttt{Mutex}, en el cual:
\begin{enumerate}
\sloppy
\item Se concretizó el \textit{abstract pointcut}, definiendo el mismo sobre el \textit{join point} \texttt{ProtocolCommand.execute()}.
\item Se especificó que \texttt{FirstLockerKeepsLock} es el tipo de estrategia elegida.
\end{enumerate}	

La codificación de estas acciones se puede ver en el listado de código \ref{fig:mutex_code3}, que
muestra la implementación del aspecto \texttt{SetTime}. En la línea 3 crea la instancia de \texttt{FirstLockerKeepsLock}
y mediante el método \texttt{setLockType()} se indica que esta es la regla a evaluar. \\
Luego entre las líneas 6 y 9 se concretiza el \textit{pointcut}, indicando que el \textit{Mutex} 
debe evaluarse sobre el método \texttt{ProtocolCommand.execute()}, de la subclase \texttt{Timestamp}.

\begin{lstlisting}[label=fig:mutex_code3,caption={Código del aspecto \textit{SetTime}.}]
public aspect SetTime extends Mutex {
  {
      setLockType(new FirstLockerKeepsLock());
  }

  protected pointcut tryLock( Object s ) :
	    call( void ProtocolCommand.execute() ) && 
	    this( s ) && 
	    target( Timestamp );
}
\end{lstlisting}

La figura \ref{fig:sec_mutex3} muestra en un diagrama de secuencia el trabajo del mecanismo
para el caso donde el protocolo \textit{G2S} tiene el \textit{lock} para el comando \textit{SetTime}.

\begin{figure}[ht!]
\centering
\includegraphics[width=5.1in]{img/5/mutex/secuencia1.eps}
\caption{Diagrama de secuencia para la ejecución del comando \textit{SetTime}.}
\label{fig:sec_mutex3}
\end{figure}

De esta manera queda completa la instanciación del mecanismo. Ante un nuevo caso de interacción que requiera de
un \textit{Mutex}, basta con subclasificar el aspecto \texttt{Mutex}, para concretizar el \textit{pointcut} y especificar el \textit{LockType}.

\subsection{Estrategias alternativas}

\sloppy
Otra estrategia de \textit{lock} implementada se denominó \texttt{ProtocolOnlineKeepsLock}.
En la misma, se eval\'ua si el protocolo que posee el \textit{lock}
está en línea. Este tipo de \textit{lock}, muestra que es posible
definir estrategias más complejas si se conocen detalles del dominio.

La figura \ref{fig:sec_mutex4} muestra un ejemplo de uso de esta estrategia, donde el protocolo \textit{PCP}
posee el \textit{lock}, pero se encuentra fuera de servicio. Cuando se recibe un comando desde el protocolo
\textit{G2S}, este obtiene el \textit{lock} y el comando es ejecutado.

\begin{figure}[ht!]
\centering
\includegraphics[width=5.1in]{img/5/mutex/secuencia2.eps}
\caption{Diagrama de secuencia de la estrategia \texttt{ProtocolOnlineKeepsLock}.}
\label{fig:sec_mutex4}
\end{figure}

  
% 44:50
\section{Conflict}
La interacción de tipo \textit{Conflict} captura las situaciones donde se producen interferencias semánticas entre aspectos. 
Esto ocurre cuando un aspecto deja de funcionar correctamente ante la presencia de otro, debido a que estos aspectos 
representan requerimientos contrapuestos.\newline
La necesidad de un mecanismo para tratar este tipo interacción, surge con el objetivo de asegurar que los aspectos que se encuentran en conflicto, funcionen de manera correcta.

Como se vio en el \ref{domain:demo}, en el dominio de las \sm~ el \cn~ de \demo~ atraviesa a:
\begin{itemize}
 \item \textbf{Game:} dado que en modo \textit{demo} debe ser posible forzar la salida de premios.
 \item \textbf{Program Resumption:} los cambios en modo \textit{demo} no deben ser persistidos en este modo.
 \item \textbf{Meters:} las regulaciones exigen que los cambios en los \textit{meters} en este modo no deben mantenerse al volver al modo normal.
 \item \textbf{Game Recall:} idem a \textit{Meters}.
 \item \textbf{Communication Protocols:} para este \cn, las regulaciones indican que una \sm~ en modo \textit{demo} debe reportase como fuera de servicio hacia los \textit{backends}.
\end{itemize}

Estos \cns, entran en conflicto con el \cn~ de \demo~ cuando este se activa. Esto genera la necesidad de contar con un mecanismo, que permita resolver
estos conflictos, alterando el comportamiento de dichos \cns.

\subsection{Tratamiento de la interacción}

Como se detalló en \ref{impl:demo}, el aspecto \texttt{Demo} implementa la funcionalidad principal del \cn~ de \demo. Dicho aspecto es el 
responsable de alterar la forma en que se realiza el sorteo aleatorio de las posiciones 
de los \textit{reels}, de forma tal de que se pueda seleccionar que premio ganar en la próxima jugada.
El aspecto utiliza una variable que representa el estado del \textit{switch} de \textit{demo}, la cual se actualiza desde dos \textit{advices} que afectan la clase \texttt{HAL}, 
uno sobre el \textit{pointcut} \texttt{demoSwitchOn()} y otro sobre \texttt{demoSwitchOff()}.
%De estar activo el modo \textit{demo}, no se procede con la ejecución normal, sino que se evita la realización
%del sorteo aleatorio de las posiciones de los \textit{reels} y se fuerza la posición de cada uno, de acuerdo
%a un determinado \textit{outcome} que el aspecto \texttt{Demo} conoce.

Dado que \textit{AspectJ} es  un lenguaje donde el proceso de \textit{weaving} se realiza en
tiempo de compilación, no es posible desvincular un aspecto en \textit{run time} como en un lenguaje dinámico.
Por ejemplo, \textbf{no es posible} evitar el conflicto con el \cn~ de \meters~ \textbf{desinstalando} el aspecto \texttt{MetersAspect}.

En la implementación del \textit{software} de la \sm, se decidió que el aspecto \texttt{Demo} ademas de implementar
la funcionalidad principal del \cn, implemente los mecanismos para tratar las interacciones que producen conflicto. 
Estas son como fue descripto, con los \cns: \meters, \resump, \comms~y \recall.

Es necesario que el mecanismo para resolver cada interacción, conozca detalles de la implementación del \cn~ 
con el que debe tratar, para poder anular parte de su funcionalidad.
La idea general para resolver estos conflictos, se basa en encontrar un \textit{join point} que de ser evitada su ejecución, se anule
la funcionalidad del \cn. A continuación se describen los detalles de implementación de cada caso.

\subsection{Tratamiento de la interacción entre los concerns: Demo y Meters}

Las regulaciones indican que los valores de los \textit{meters} que se modifiquen
en modo \textit{demo} no deben verse reflejados como cambios al salir de este modo.
En cambio, no especifican que acción realizar con los valores actuales de los \meters~ cuando se pasa a modo \textit{demo}. \newline
En la implementación realizada, se tomo la decisión de reiniciar los valores al activarse
el modo \textit{demo} y restaurar los mismos al volver a modo normal.

Como se detalló en \ref{impl:meters}, la implementación del \cn~ de \meters~ utiliza 
una instancia de la clase \texttt{MeterManager} para guardar los valores de los \textit{meters}. Esta instancia es utilizada
para almacenar los valores de los \textit{meters} por los subaspectos que afectan diferentes partes del sistema.
La resolución del conflicto, se basa en cambiar la instancia de \texttt{MetersManager} que estos aspectos utilizan,
al estar la \sm~en modo \textit{demo}.

Como muestra la figura \ref{fig:conflict:demo1}, el aspecto \texttt{Demo} afecta el método \texttt{getManager()}
del aspecto \texttt{MetersAspect}. Si el modo \textit{demo} se encuentra activo, se retorna una instancia de \texttt{MetersManager}
que es mantenida por el aspecto \texttt{Demo}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=.6]{img/5/conflict/demo.eps}
\caption{El aspecto \texttt{Demo} afecta el \textit{join point} \texttt{MetersAspect.getManager()}.}
\label{fig:conflict:demo1}
\end{figure}
\FloatBarrier

El fragmento de código \ref{fig:conflict_code1} muestra el \textit{around advice} utilizado para tratar el conflicto con el
\cn~ de \meters. Cuando el \textit{join point} \texttt{MetersAspect.manager()} es alcanzado
en tiempo de ejecución, en la línea 4 del \textit{advice}, se evalúa si el modo \textit{demo} se encuentra activo. Si este es el caso, 
se retorna una instancia del objeto \texttt{MetersManager} que es local al aspecto \texttt{Demo}, como se puede ver en la línea 5. \newline
Cuando la evaluación de la condición es falsa, se procede a ejecutar de manera normal el método (línea 6). Esto retornará la instancia 
de \texttt{MetersManager} del aspecto \texttt{MetersAspect}, que no sufrió alteraciones durante el modo \textit{demo}.

\begin{lstlisting}[label=fig:conflict_code1, caption=\textit{Around advice} del aspecto \texttt{Demo} utilizado para tratar el conflicto con el \cn~de \meters.]
MetersManager around() : 
	      execution( MetersManager MetersAspect.manager()
{
  if (_demoIsOn) {
      return _fakeMetersManager;
  }else{
      return proceed();
  }
}
\end{lstlisting}

Esta forma de resolver el conflicto, implica que el aspecto \texttt{Demo} conozca que reemplazando la instancia del 
objeto \texttt{MetersManager} del aspecto \texttt{MetersAspect}, anula el \cn~ de \meters. \newline
La misma estrategia puede utilizarse para el conflicto con el \cn~ de \recall, donde el aspecto \texttt{GameRecallAspect}
tiene como colaborador una instancia de la clase \texttt{GameRecallManager}.

\subsection{Tratamiento de la interacción entre los concerns: Demo y Program Resumption}

La responsabilidad del \cn~ de \resump~ consiste en persistir ciertos datos de la \sm, por ejemplo los valores de los \textit{meters}.
Las regulaciones señalan que los valores de configuración o estados que varíen en modo \textit{demo}, deben ser revertidos al salir de este modo.

Como se vio en la secci\'on \ref{impl:resump}, la implementación del \cn~ de \resump~ se compone de una jerarquía de aspectos.
Los subaspectos utilizan métodos que el aspecto \texttt{ProgramResumptionAspect} provee,
para obtener y guardar datos, utilizando los servicios provistos por la \textit{HAL}.\\
Los métodos del aspecto \texttt{ProgramResumptionAspect} retornan un valor de tipo \textit{boolean}, esto indica si la operación
pudo ser realizada en la \texttt{HAL}. El mecanismo para resolver el conflicto en modo \textit{demo}, consiste
en evitar la ejecución de los métodos de la superclase, anulando la funcionalidad del \cn~de \resump.

Como se puede ver en el fragmento de código \ref{fig:conflict_code2}, se utiliza un \textit{pointcut} que captura la ejecución de todos 
los métodos que retornan un valor de tipo \textit{boolean} del aspecto \texttt{ProgramResumptionAspect}. De la misma manera que para el
\cn~ de \meters, se procede con la ejecución normal si el modo \textit{demo} no se encuentra activo. De no ser así, se retorna \texttt{false},
indicando que la operación no pudo ser realizada en el objeto \texttt{HAL}.

\begin{lstlisting}[label=fig:conflict_code2,caption=\textit{Around advice} del aspecto \texttt{Demo} utilizado para tratar el conflicto con el \cn~de \resump.]
boolean around() : 
	execution( boolean ProgramResumptionAspect.*(..) );
{
  if (_demoIsOn) {
      return false;
  } else {
      return proceed();
  }
}
\end{lstlisting}

En este caso, el acoplamiento entre el mecanismo y el \textit{concern} de \resump~ es alto. La solución se basa en
conocer que los métodos del aspecto base son utilizados por la jerarquía y que anulando su ejecuci\'on se evita el conflicto.% y además,
% que si los mismos retornan \textit{false} esto anula la operación que realizan los subaspectos.
% En este mecanismo, el aspecto \texttt{Demo} no conoce sobre la interacción del \cn~ de \resump~ con
% otros objetos, pero si sabe de que este \cn~ se compone de una jerarquía y el significado del valor de 
% retorno de los métodos del aspecto \texttt{ProgramResumptionAspect}.

\subsection{Tratamiento de la interacción entre los concerns: Demo y Communication Protocols}

Con el objetivo de mantener consistentes los datos en los sistemas de monitoreo, las regulaciones indican que una \sm~ en
modo \textit{demo} debe reportase como fuera de servicio. \\ Por esto, no deben enviarse notificaciones de eventos, que de 
producirse estando la \sm~ en modo normal, serían reportados. Un ejemplo de esto, es el evento de \textit{begin game}. 
Además, una \sm~ en modo \textit{demo} que recibe comandos de  consulta desde un servidor, debe responder con un mensaje 
que indique que se encuentra fuera de servicio.

Como se detall\'o en \ref{c4.comm}, los aspectos del \cn~ de \comm~ monitorean el comportamiento de determinados objetos 
con el objetivo de reportar eventos a los servidores. Dichos eventos son enviados utilizando el método \texttt{sendEvent()} del objeto \texttt{CommProtocol}. \\
Por otro lado, cuando un objeto \texttt{CommProtocol} recibe un comando desde los sistemas de monitoreo, dicho comando es procesado si el protocolo se encuentra
en línea. En caso contrario, se retorna un mensaje que notifica que el protocolo esta fuera de servicio.

Tanto al recibir un comando, como al enviar un mensaje, un objeto \texttt{CommProtocol} valida mediante el m\'etodo \texttt{isOnline()} cual es su estado.
Este \textit{join point} es el que utiliza el mecanismo para resolver el conflicto con el \cn~de \comm. El listado de código \ref{fig:conflict_code3},
contiene la implementaci\'on del \textit{around advice}. De la misma manera que con los casos anteriores, sólo se ejecuta el \texttt{proceed()} si el modo \textit{demo} 
no se encuentra activo, en caso contrario se retorna \textit{false}.

\begin{lstlisting}[label=fig:conflict_code3,caption=\textit{Around advice} del aspecto \texttt{Demo} utilizado para tratar el conflicto con el \cn~de \comm.]
  boolean around() : 
	  execution( boolean CommProtocol.isOnline() );
  {
      if (_demoIsOn) {
	  return false;
      } else {
	  return proceed();
      }
  }
\end{lstlisting}

De esta manera, si el modo \textit{demo} se encuentra activo, los cambios de estados en la \sm~ no seran reportados por los protocolos. 
De la misma forma, al recibir un comando desde los sistemas de monitoreo la \sm~ se reportar\'a como fuera de servicio.

\subsection{Generalización del mecanismo}

Analizando los casos planteados, se observa que todos los conflictos fueron tratados utilizando un \textit{around advice} que retorna
un valor que anula la funcionalidad del \cn~en conflicto. El cuadro \ref{conflict:table}
muestra para cada \cn~en conflicto, el \textit{pointcut} sobre el que se instalo el \textit{around advice} y
el valor de retorno utilizado cuando el modo \textit{demo} se encuentra activo.

\begin{table}[h]
\centering
\caption{\textit{Pointcuts} y valores de retorno utilizados para resolver los conflictos.}
\begin{tabular}{| p{3cm} | p{6cm} | p{4cm} | } 
\hline
\textbf{\textit{Concern} en conflicto}& \textbf{\textit{Pointcut} que anula el conflicto}& \textbf{Valor de retorno que resuelve el conflicto} \\
\hline
\meters & \texttt{MetersAspect.manager()} & \textit{fake} \texttt{MetersManager}  \\
\hline
\recall & \texttt{GameRecallAspect.manager()} & \textit{fake} \texttt{GameRecallManager}\\
\hline
\resump & \texttt{ProgramResumptionAspect.*} & \texttt{false} \\
\hline
\comm  & \texttt{CommProtocol.isOnline()} & \texttt{false}  \\
\hline
\end{tabular}
\label{conflict:table}
\end{table}

En los \textit{advices} utilizados para resolver los conflictos se detectó un patrón que se muestra en el listado \ref{fig:conflict_code4}.
Utilizando el mismo, la resolución de un conflicto se puede resumir en los siguientes pasos:
\begin{enumerate}
 \item Definir el \textit{pointcut} que captura el o los puntos del código en los cuales alterando su valor de retorno, se ``desactiva'' el \cn~en conflicto.
 \item Detectar cual es el valor de retorno necesario en este \textit{pointcut}, para anular el conflicto.
 \item Instanciar un \textit{around advice} sobre el \textit{pointcut} identificado, que retorna el valor detectado en caso de estar en una situación de conflicto o
 permite la ejecución normal en caso contrario.
\end{enumerate}

\begin{lstlisting}[label=fig:conflict_code4,caption=Patrón detectado en los casos implementados.]
  RETURN_TYPE around() : POINTCUT()
  {
      if (CONFLICT_CONDITION) {
	  return CONFLICT_RESOLUTION_VALUE;
      } else {
	  return proceed();
      }
  }
\end{lstlisting}

% time 30.52
\section{Dependency}
Esta forma de interacción cubre las situaciones donde un aspecto \textit{A}, para funcionar de manera correcta, 
depende de otro aspecto \textit{B}. Si \textit{B} no está presente, el comportamiento de \textit{A} podría generar errores 
en el \textit{software}. Dada la característica de \textit{obliviousness} entre aspectos \cite{filman:aosdbook05},
es necesario desarrollar un mecanismo que garantice que no se produzcan errores entre aspectos dependientes.

En el \textit{software} de las \sm~ los protocolos deben responder consultas, como se vio en \ref{domain:comm}. 
Por ejemplo, si el protolo \textit{PCP} recibe una consulta sobre el valor de un \textit{meter} determinado, es necesario
consultar al \cn~de \textit{Meters} sobre el mismo. Si este \cn~no está funcionando, es decir los \textit{meters} no están siendo actualizados,
el valor que reporte el protocolo será incorrecto.
Existe entonces una interacción de tipo \textit{dependency}, entre los \cns~ de: \meters~ y \comms.

\subsection{Tratamiento de la interacción}

A nivel de implementación como se detalló en el capítulo 4, los aspectos del \cn~ de \meters~mantienen actualizados el
objeto \texttt{MetersManager}. El mismo contiene los valores de los \textit{meters} y tiene la capacidad de retornar el valor
actual de un determinado \textit{meter}. Como también fue detallado, los protocolos de comunicación al recibir una instancia de \texttt{ProtocolCmd},
proceden a ejecutar el método \texttt{execute()} del mismo.

Como se puede ver en la figura \ref{fig:imp_dependency1}, es necesario que en la ejecución del método
\texttt{GetMeter.execute()}, se pueda obtener del objeto \texttt{MetersManager} el valor del \textit{meter} correspondiente.
Esta interacción, genera una dependencia desde el comando de protocolo \texttt{GetMeter} hacia el objeto 
\texttt{MetersManager}, objetos de los \cns~ de \comm~ y \meters~ respectivamente.

\begin{figure}[ht!]
\centering
\includegraphics[width=5.1in]{img/5/dependency/clases.eps}
\caption{Dependencia entre los objetos \texttt{GetMeter} y \texttt{MetersManager}}
\label{fig:imp_dependency1}
\end{figure}

Esta es una relación de conocimiento que cruza las fronteras de los \textit{concerns}. A nivel de requerimientos 
y diseño, es deseable que la dependencia sea documentada de manera explicita. Sin embargo, a nivel de implementación 
no es necesario el desarrollo de un mecanismo para su tratamiento, ya que es una relación de 
colaboración que puede resolverse de diferentes maneras.

Para resolver la dependencia, una opción es que el objeto \texttt{GetMeter} tenga una referencia a la instancia de \texttt{MetersManager}. La 
misma podría ser recibida por parámetro en el constructor de la clase \texttt{GetMeter}. De esta manera, cuando  
el método \texttt{GetMeter.execute()} es procesado, se consulta directamente el valor del \textit{meter} requerido a este objeto.

Otra alternativa, es utilizar un \textit{before advice} sobre el método \texttt{execute()}. En el mismo se guarda
el valor del \textit{meter} requerido en una variable de instancia del objeto \texttt{GetMeter}. De esta manera al ejecutar el método,
se dispone del valor actualizado.

\subsection{La interacci\'on de tipo Dependency no requiere una implementaci\'on ad-hoc}

Para asegurar que la interacción de tipo \textit{dependency} planteada, no genera problemas en el \textit{software} de una \sm, es necesario que se cumplan las siguientes condiciones:
\begin{enumerate}	
 \item Que el sistema cuente con la funcionalidad del \cn~ de \textit{Meters} para que el \cn~ de protocolos pueda realizar la consulta. En este caso
 es necesario que el objeto \texttt{MetersManager} exista.
 \item Que el \cn~ de \textit{Meters} este funcionando correctamente. Es decir, que los aspectos estén actualizando los
 valores del objeto \texttt{MetersManager}.
\end{enumerate}

Para dar por v\'alido el punto 1, nuestra implementaci\'on nos asegura que:
\begin{itemize}
 \item Una \sm~ no puede funcionar sin el módulo de \meters, como es indicado por las regulaciones.
 \item El objeto \textit{MetersManager} siempre va a estar creado e inicializado en \textit{runtime}.
\end{itemize}

De esta manera, se descartan mecanismos básicos de \textit{runtime check}. Por ejemplo, 
validar que el objecto \texttt{MetersManager} no sea \texttt{nil} antes de solicitarle el valor de un \textit{meter}.

Para el punto 2, como el objeto \texttt{MetersManager} es actualizado por diferentes aspectos,
un posible mecanismo podría consistir en asegurar que estos aspectos esten funcionando 
y por ende el objeto \textit{MetersManager} tenga los valores correctos.  \newline
Pero para que esto no ocurra, deberían cumplirse alguna de las siguientes condiciones:
\begin{itemize}
  \item Que los aspectos que actualizan el objeto \texttt{MetersManager} no esten instalados. Esto puede pasar por
  estar utilizando un lenguaje donde el proceso de \textit{weaving} sea dinámico, lo cual no se cumple con \textit{AspectJ}. 
  Tambi\'en puede ocurrir si se utilizara \textit{load-time weaving}, lo cual tampoco se cumple dado que la implementaci\'on realizada
  cuenta con una \'unica configuraci\'on.
  
  \item Que no se cumplan determinadas condiciones que los aspectos del \cn~ de \meters~ validan antes de actualizar el objeto \texttt{MetersManager}
  y que el \cn~ de \comm~ desconoce.
\end{itemize}	

De cumplirse esta última condición, los valores de los \meters~ serían inválidos. \newline
Sin embargo, esta necesidad de asegurar consistencia es responsabilidad del \cn~ de \meters~ y no de un mecanismo 
para tratar interecciones de tipo \textit{Dependency}.

Si bien es necesario a nivel de requerimientos y diseño, indicar la relación de dependencia;
de lo anterior se concluye que en la implementación no es necesario un mecanismo para tratar la interacción. 
Si no se cumple alguna de las condiciones planteadas, sería correcto que el sistema falle. \\
Este puede ser el caso de una \textit{NullPointerException} si el \texttt{MetersManager} no est\'a inicializado. Un mecanismo 
de \texttt{try/cath} que proteja al sistema de la posibilidad de que el \texttt{MetersManager} sea \texttt{nil}, sería redundante.
Si pudiera hacer \textit{unweaving} de un aspecto, se podría chequear la presencia del mismo. Pero nuevamente, se está protegiendo 
al sistema de cosas que no pueden pasar dentro de este contexto.

% \todo{ver que pasa con demo que deshabilita los aspectos}
% \todo{NOTAS}
% - para la impl del mecanismo, se toma como obligatoria, si está se tiene que cumplir. Es decir si no se cumple el aspecto dependinte no debe ``proceder``
% - En el ProtocolCmd la dependencia está implicita, porque conoce al MetersManager. El objeto como objeto siempre esta. Lo que hay que validar es que ese objeto del que se depende tiene valores validos.
% 
% Si pudiera hacer unweaving de ese aspecto podria chequaer presencia, pero me estoy protegiendo de cosas que no pueden pasar dentro de este contexto.
% Si para el concern de demos trabajo con otro conjunto de meters... el demo se las debe arreglar, es responsabilidad de el y por ser otro concern el concern de meters ni se entera de q eso pasa. Si pienso que demo no existe eso no pasa nunca.
% Una de las cosas que se plantean con dependencia es q no podes armar un sistema si no tiene meters. runtime check,
% Asumo que siempre esta pero tengo un trycatch para bajar el sistema.
% 
% La dependencia se reduce al hecho de que la referencia es implicita y si no es NIl esta ok, a nivel implementación.
% 
% existe una relacion q cruza las fronteras de los modulos "concerns" y hay q marcarlo explicitamtnte a nivel requerimientos y diseño, pero a nivel impl eso no es nada, rompo el encapsulamitno.
% 
% es tan simple como una relacion de conocimiento.
% 3 opciones
% -concepto de consistencia
%   1. lazy,  lo puedo validar en cada op, necesito de contadores, mucho overhead, 
%   2. por grupo. ante un getMeter no valida justo ese, sino el grupo, +overhead?, -condadores

% 19:55
\section{Reinforcement}

Este tipo de interacción se produce cuando la presencia de un aspecto influye positivamente sobre otro,
permitiendo que este último pueda extender su funcionalidad.

Como fue visto en el capítulo anterior, el \textit{software} de una \sm~cuenta con la capacidad de 
detectar condiciones de error y tratar las mismas de acuerdo a lo que indican las regulaciones. Las
\textit{errors conditions} se generan a partir de determinadas señales de \textit{hardware}, por 
esto, el conjunto de \textit{errors conditions} que puede ser detectado en una \sm, puede variar de una a otra.

A la vez, las regulaciones indican que los protocolos deben notificar las \textit{errors conditions} 
a los servidores de monitoreo, cuando la \sm~ tenga la capacidad de detectarlas.
Cada protocolo tiene un conjunto de \textit{errors conditions} que le interesa reportar, pudiendo este 
conjunto variar entre diferentes protocolos. 
De esta manera, los protocolos pueden ampliar su funcionalidad, gracias a la información que provee el \cn~
de \errors. Se produce entonces una interacción de tipo \textit{reinforcement} entre los \cns~ de \errors~ y de \comms. 

\subsection{Tratamiento de la interacción}

El objetivo del mecanismo desarrollado es que el programador tenga que tomar una decisión expl\'icita sobre notificar o no una 
\textit{error condition}. Es deseable que en situaciones en donde el \textit{software} de la \sm~ escala,
el mecanismo ayude a que el programador no olvide reportar las \textit{error conditions}. Este puede ser el caso en donde
se implementa un nuevo protocolo o el sistema
tiene la capacidad de detectar una nueva \textit{error condition}.

Como se detalló en el capítulo anterior, el \textit{concern} de \textit{HAL} 
notifica a los \textit{listeners} registrados ante una
\textit{signal}. Como se vio en la secci\'on \ref{c4.comm}, el \textit{listener} que registra 
el \cn~ de \error~ es quien crea un instancia de \texttt{ErrorCondition} y luego invoca
al método \texttt{ErrorCondition.applyActions()}. Este es el \textit{join point} de interés 
al que se asocia la ejecución del mecanismo que se describe a continuación.

Para tratar esta interacción positiva y ayudar a que la misma se produzca, se desarrolló un mecanismo \textit{ad-hoc}.
Dicho mecanismo agrega a una \texttt{ErrorCondition} la 
capacidad de notificarse en \textbf{un} protocolo. Cuando un protocolo captura la ejecución del método
\texttt{ErrorCondition.applyActions()}, solicita a la instancia de esta \textit{error condition}
que se notifique. 

\sloppy
Para esto, se alteró la estructura de la jerarquía \texttt{ErrorCondition} mediante el uso de \textit{inter-type declarations}, 
desde los aspectos de la jerarquía \texttt{CommProtocolAspect}.
La figura \ref{fig:reinforcement_img1}, indica la modificación que introduce el aspecto \texttt{G2SAspect} en la clase
\texttt{ErrorCondition}. En dicho aspecto se define el método abstracto \texttt{notifyG2S()}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=.6]{img/5/reinforcement/clases.eps}
\caption{El método \texttt{notifyG2S()}  es agregado a la clase \texttt{ErrorCondition}, desde el aspecto \textit{G2SAspect}.}
\label{fig:reinforcement_img1}
\end{figure}

\FloatBarrier
La codificación de esta acción para el protocolo \textit{G2S}, se puede ver en el fragmento de código
 \ref{fig:reinforcement_code1}. De esta manera, cada subclase de la jerarquía \texttt{ErrorCondition}, 
 \textbf{deberá} implementar el método abstracto \texttt{notifyG2S()}. 

\begin{lstlisting}[label=fig:reinforcement_code1, caption=Método agregado a la clase \texttt{ErrorCondition} mediante el uso de \textit{inter-type declarations}.]
public aspect G2SAspect extends CommProtocolAspect {
  ...
  public abstract void ErrorCondition.notifyG2S(); 
}
\end{lstlisting}

\sloppy
Luego, el aspecto \texttt{G2SAspect} define un \textit{before advice}. El mismo se asocia al \textit{pointcut} que captura 
\texttt{ErrorCondition.applyActions()}. Como muestra el fragmento de código \ref{fig:reinforcement_code2} en la l\'inea 7,
en dicho \textit{advice} se invoca el método \texttt{notifyG2S()} sobre la \textit{error condition} detectada.

\begin{lstlisting}[label=fig:reinforcement_code2, caption=\textit{Before advice} que detecta una \textit{error condition} y solicita la notificación de la misma.]
public aspect G2SAspect extends CommProtocolAspect {
  ...
  before( ErrorCondition errorCondition ) : 
	  target(errorCondition) &&
	  execution(void ErrorCondition.applyActions());
  {
      errorCondition.notifyG2S();
  }
}
\end{lstlisting}

En cada subclase de la jerarquía de \texttt{ErrorCondition}, el método \texttt{notifyG2S()} contiene
la implementación concreta para notificar la \textit{error condition} en el protocolo \textit{G2S}.
Como se puede ver en la figura \ref{fig:reinforcement_img2}, para la subclase \texttt{DoorOpen}, 
este comportamiento también es agregado mediante el uso de \textit{inter-type declarations} en el aspecto 
\texttt{G2SAspect}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=.6]{img/5/reinforcement/clases2.eps}
\caption{El método \texttt{notifyG2S()}  es agregado a la clase \texttt{DoorOpen} por el aspecto \textit{G2SAspect}.}
\label{fig:reinforcement_img2}
\end{figure}

\FloatBarrier
Por cada ocurrencia de una \error~ que un protocolo esté interesado en notificar,
debe enviar el evento correspondiente. El fragmento de código \ref{fig:reinforcement_code3}, 
muestra la implementación del método \texttt{notifyG2S()} para el caso de la \textit{error condition} \texttt{DoorOpen}. 
En la línea 4, se crea un evento que representa dicha \textit{error condition} y es enviado por el protocolo \textit{G2S}.

\begin{lstlisting}[label=fig:reinforcement_code3, caption=Implementación del método \texttt{notifyG2S()} en la \textit{error condition} \texttt{DoorOpen}.]
public aspect G2SAspect extends CommProtocolAspect {
  ...
  public void DoorOpen.notifyG2S() {
      protocol().sendEvent( new DoorOpenEvent() );
  }
}
\end{lstlisting}

Cuando una nueva \texttt{ErrorCondition} es agregada al sistema, se genera un error
de compilación si el método \texttt{notifyG2S()} no está implementado.
De esta manera, el desarrollador deberá redefinir el método, viéndose obligado a decidir
explicitamente si dicha \texttt{ErrorCondition} debe o no ser reportada.

En el caso de que un nuevo protocolo sea agregado al sistema, o si es necesario que	un protocolo existente cuente con la
capacidad de notificar \textit{errors conditions}, se deberán realizar las siguientes acciones:

\begin{itemize}
\item Introducir mediante \textit{inter-type declarations} el método \texttt{notifyProtocolName} en la superclase \texttt{ErrorCondition}.
\item Definir el \textit{before advice} que solicita a una instancia de \texttt{ErrorCondition} que se notifique al
capturar el \textit{joint point} \texttt{ErrorCondition.applyActions()}.
\item Definir el método \texttt{notifyProtocolName} en cada \textit{error condition} de la jerarquía. En el cuerpo
de este método, se debe completar la funcionalidad requerida para reportar la \textit{error condition} o, dejar el método vacío.
 En este caso se indica de manera expl\'icita, que esa \textit{error condition} particular no necesita ser reportada.
\end{itemize}

La figura \ref{fig:reinforcement_img3}, muestra el resultado de agregar la funcionalidad de reportar las
\textit{erros conditions} en el protocolo \textit{PCP}. Por cada nuevo protocolo, la superclase \texttt{ErrorCondition},
contendrá el método abstracto que las subclases deben definir.

\begin{figure}[ht!]
\centering
\includegraphics[scale=.6]{img/5/reinforcement/clases3.eps}
\caption{Resultado de agregar la capacidad de notificar \textit{error conditions} en el protocolo \textit{PCP}.}
\label{fig:reinforcement_img3}
\end{figure}

\FloatBarrier
De esta manera, queda completa la descripción del mecanismo para resolver la interacción de tipo \textit{reinforcement}.
Con la solución descrita, se logró que una decisión expl\'icita deba ser tomada cuando
una \error~ es agregada al sistema, favoreciendo a que esta interacción positiva se produzca.

%El mismo permite que una \error~ pueda o no ser notificada en un determinado protocolo, dependiendo de la implementación del método \texttt{notifyProtocolName()}.\newline

El código que compone la solución se divide entre las jerarquías de \texttt{CommProtocol} y \texttt{ErrorCondition}. 
Sin embargo, el comportamiento agregado en la jerarquía de \texttt{ErrorCondition}
se hizo mediante el uso de \textit{inter-type declarations}, quedando la totalidad del código en el módulo de \comms.

%Más específicamente, en el aspecto que corresponde al protocolo que desea notificar las \textit{errors conditions}.

%Por último, si un nuevo protocolo es añadido, se deberá
%implementar el método \texttt{notifyNewProtocol()} en la jerarquía de \texttt{ErrorCondition} para que las mismas sean notificadas.
%
%
%	VER DONDE PONER 
%También se requiere que deba ser posible especificar para cada \error~ si
%debe ser notificada o no por un determinado protocolo. \newline
%Además, sería beneficioso que el mecanismo fuerze al programador a tomar esta decisión cuando
%una \error~ es agregada al sistema, favoreciendo a que esta interacción positiva se produzca.

\section{Análisis de los mecanismos desarrollados}
A continuación se presenta un análisis de los mecanimos desarrollados. 
Se discuten ventajas y desventajas en lo referido a generalización, modularización, escalabilidad y otros factores, 
para cada una de las soluciones que fueron presentadas en este capítulo.

\subsection{Modularización}
En el mecanismo presentado para tratar la interacción de tipo \textbf{Mutex} se obtuvo un desarrolló modular, en el cual
los aspectos del dominio son independientes de la implementación de \textit{mutex}. \newline
Cada \textit{mutex} queda encapsulado en un aspecto, por lo tanto, para incluir un \textit{mutex} alcanza con compilar el aspecto que lo contiene.
Por el contrario, para eliminar el \textit{mutex}, se debe excluir del proceso de compilación el aspecto que lo implementa.
Notar que no hay necesidad de modificar algún objeto u aspecto del sistema y que en \textit{AspectJ} es posible configurar que aspectos forman
parte de una determinada compilación.
% Esto puede ser necesario en casinos donde no se produzcan 
% interacciones de este tipo, debido a que se utiliza un solo protocolo de comunicación. 

En lo que respecta a la solución para tratar una interacción de tipo \textbf{Conflict}, el mecanismo
desarrollado fue incorporado dentro del aspecto que contiene la funcionalidad principal del \cn~ \demo. \newline
Desacoplar completamente el mecanismo generaría una interacción de tipo \textit{Dependency} 
entre el aspecto \textit{Demo} y el aspecto que resuelve el conflicto. Esto es debido a que el modo \textit{demo},
requiere para activarse tanto de su funcionalidad principal como de la resoluci\'on de los conflictos que se producen con el resto
de los \cns.

Como fue detallado, para resolver las interacciones de tipo \textbf{Reinforcement}, se defini\'o un mecanismo que requiere 
ser implementado completamente para cada protocolo. Dado el uso de \textit{inter-type declarations}, el código que lo implementa
se encuentra en el \cn~de \comms, m\'as espec\'ificamente en el aspecto que implementa la funcionalidad del protocolo. 
Esta implementación podría modularizarse aún más, separando el código del mecanismo en otro aspecto.

\subsection{Generalización}
%Parrafo indicando a que nos referimos con generalizacion
De los mecanismos desarrollados, se logró generalizar la solución para las interacciones de tipo \textbf{Mutex}. \newline
La implementación del mecanismo \textit{Mutex}, puede ser reutilizada para otros aspectos, ya que la misma es independiente
del dominio subyacente.
Algunas de las estrategias implementadas para la resolución del \textit{mutex}, también son independientes y pueden ser reutilizadas sin
modificaciones.

% La indenpendencia lograda sobre los \textit{concerns} del dominio, es la que permite el reuso de este mecanismo en otros
% objetos u aspectos donde pueda disponerse de un \textit{jointpoint} sobre el cual se produce el conflicto.
% Además, el reuso que se ve favorecido por la colección de estrategias que se encuentren implementadas.

Para la interacciones de tipo \textbf{Conflict} no se obtuvo una generalización del mecanismo, pero sí se detectó
un patrón de resolución en los casos implementados. El mismo consiste en tratar cada conflicto con un \textit{around advice}, el cual
permite continuar la ejecución normal de no mediar conflicto. \\No fue posible implementar un solución genérica para tratar esta interacción.
Como se mostr\'o en la tabla \ref{conflict:table}, cada caso necesita de un tratamiento particular y adem\'as, no es posible referenciar
los \textit{advices} en \textit{AspectJ} dado que son anónimos.

\subsection{Escalabilidad}
Es esperable que se generen nuevos casos donde sea necesario el mecanismo \textbf{Mutex}. Esto puede deberse por ejemplo, a nuevos 
comandos que modifiquen el estado de la \sm~ y los mismos puedan ser recibidos por más de un protocolo de comunicación.\newline
En este sentido la solución presentada es escalable.
Cuando un nuevo comando requiera ser tratado con un \textit{Mutex}, 
s\'olo se debe definir un aspecto que define de manera concreta el \textit{abstract pointcut} y
especificar cual es la política a utilizar para determinar la obtención del \textit{lock}.
% De ser necesario una estrategia que no esté implementada, será necesario subclasificar la clase \texttt{LockType} e implementar 
% el método \texttt{tryLock( Object o )}, como fue detallado.

La solución para las interacciones de tipo \textbf{Conflict}, puede ser utilizada en
nuevas situaciones donde logre identificarse un \textit{join point}, que de evitar su ejecuci\'on prevenga la ocurrencia de un conflicto.
Utilizando el patrón detectado, se debe definir un \textit{around advice} sobre el
\textit{pointcut} en donde el conflicto se produce.

En el caso de las interacciones de  tipo \textbf{Reinforcement} es necesario contemplar que el sistema puede evolucionar de dos maneras: ante la aparici\'on 
de una nueva \textit{Error Condition} y el soporte para nuevos protocolos.
Por lo tanto vemos que el mecanimo presentado permite extender el sistema correctamente.\newline
En primer lugar, cuando una nueva \error~ es agregada al sistema, se deberán agregar a la misma los método
\texttt{notifyProtocol()} para cada uno de los \comms. \newline
Por otro lado, se podría dar el caso de que se añada un nuevo protocolo, en esta situación
se deberá implementar en la jerarquía de \texttt{ErrorCondition} el método 
\texttt{notifyNewProtocol()}.

\subsection{Mantenibilidad}
Una desventaja o carencia del mecanismo \textbf{Mutex}, con respecto a la mantenibilidad, es la imposibilidad de notificar la
falta del mismo cuando es necesario. Está claro que para nuevos casos, donde sea necesario un \textit{Mutex}, es en
la etapa de diseño donde debe indicarse. \newline
Sin embargo, se pueden generar inconsistencias en la \sm~ para los casos donde un determinado \textit{pointcut} pase a ser inválido, debido a que
se modifica la estructura de la clase que lo contiene. En el caso de \textit{AspectJ}, el desarrollador 
solo recibirá un \textit{warning} de que no se pudo realizar el \textit{weaving} de manera correcta.\\
Este es un problema conocido como \textit{fragil pointcut problem} \cite{ecoop-aaos03, KoppenStoerzer2004.eiwas} donde 
dada la limitada expresividad para definir los \textit{pointcuts} que brindan los lenguajes, dichos \textit{pointcuts}
suelen estar acoplados a la estructura del código base. Como consecuencia de ello, cambios seguros en el código de base, pueden
tener un impacto inesperado e indeseable sobre el comportamiento de los aspectos en el sistema.

% Una forma sencilla de separar la resolución para el tipo \textbf{Conflict}, podría ser
% subclasificando el aspecto \texttt{Demo}. De esta forma, se reusa 
% la lógica que mantiene la variable que indica si el modo \textit{demo} se encuentra activo. \newline
% Además, se evita generar una interacción de tipo \textit{Dependency} como fue explicado.

El \cn~ \demo~ produce una interacción de tipo \textbf{Conflict} con varios 
\cns~ del dominio, la implementación de esta interacción complica la mantenibilidad. \newline
 Como fue detallado, en este caso se utiliza un \textit{around advice}
que retorna un valor que anula el conflicto. Es por ello, que no sólo se debe 
prestar atención a casos de \textit{pointcuts} inválidos, sino también a los cambios 
en la interpretacion que se hace de los valores de retorno, ya que pueden invalidar
la resolución del conflicto.

Por otro lado, tareas de \textit{debugging} se verán afectadas por el mecanismo \textbf{Conflict}, debido
a que los \textit{around advices} se encuentran siempre instalados, aún cuando el modo \textit{demo} no está
activo. \newline
Esto podría resolverse de dos maneras: una opción es tener dos binarios, donde uno
de ellos tiene el mecanismo desarrollado. Luego, dependiendo del estado del \textit{switch} 
de \textit{demo}, se decide cual utilizar. Esto duplica el costo de certificar un juego, dado que se cuenta con 2 aplicaciones.\newline
Otra opción, es utilizar una característica de \textit{AspectJ} que permite realizar el \textit{weaving} en tiempo de carga. De 
esta manera se podría configurar si disponer o no del modo \textit{demo}. Ambas opciones descriptas requieren reiniciar el \textit{software} de la \sm.

Aunque no hubo necesidad de desarrollar un mecanismo \textit{ad-hoc} para la interacci\'on de tipo \textbf{Dependency}, la misma 
es dif\'icil de mantener, dado que no hay algo expl\'icito en el c\'odigo fuente que ayude a preservarla.

\subsection{Weaving dinámico}

Para finalizar, dada la experiencia de haber trabajado con \textit{AspectS} \cite{alvarez:jaiio}, 
se discuten a continuación características de los mecanismos que se verían
afectadas si se utilizara una lenguaje de \textit{weaving} dinámico.

Para la intereracción de tipo \textbf{Dependency} no hubo necesidad de desarrollar un mecanismo. 
Como fue descripto, esto se debe en principio al uso de un lenguaje estático. Si este no fuera el caso,
sería necesario un tipo de chequeo que permita asegurar que el \cn~ del que se depende se encuentre activo.\newline
Para el caso específico de \textit{Meters}, se debería controlar que el objeto \texttt{MetersManager} 
este siendo actualizado y de no ser asi, no reportar los valores en los protocolos de comunicación.

En el caso de la solución propuesta para el tipo \textbf{Conflict}, de usar \textit{weaving} dinámico,
los aspectos podrían ser instalados y removidos en tiempo de ejecución seg\'un el estado del \textit{switch} de \textit{demo}. 

Por último, el mecanismo presentado para la interacción de tipo \textbf{Reinforcement}, 
obliga a decidir explicitamente si una \textit{Error Condition} debe o no ser reportada antes de la compilación.
De utilizar un lenguaje de \textit{weaving} dinámico y no tomar la decisión de notificar una \error,
un error en tiempo de ejecuci\'on se producir\'ia cuando se intenta notificar una \error~por primera vez.

% \section{Resumen del capítulo}
% 
% En este capítulo se describieron los mecanismos desarrollados para tratar las interacciones según
% la clasificación de Sanen~\etal, donde se puede destacar:
% 
% \begin{itemize}
% \item \textbf{Mutex}: se desarrolló un mecanismo que puede ser reutilizado en otros dominios. 
% \item \textbf{Conflict}: se resolvió mediante el uso de mecanismo \textit{ad-hoc}, sobre el que se encontro un patrón.
% \item \textbf{Dependency}: se concluyó que no hace falta un mecanismo para tratar las interacciones de este tipo.
% \item \textbf{Reinforcement}: se implementó una solución \textit{ad-hoc} utilizando \textit{AspectJ Introduction}.
% \end{itemize}
% 
% Por último, se presentó un análisis de los mecanismos desarrollados, donde se discutieron
% ventajas y desventajas en lo referido a generalización, modularización, escalabilidad y otros factores.

\ifx\all\undefined
\end{document}
\fi
