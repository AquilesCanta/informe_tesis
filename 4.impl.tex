\ifx\all\undefined
\include{0.base}
\begin{document}
\fi
 
\chapter{Implementación Orientada a Aspectos de una SM}
\chaptermark{Implementación AO de una SM}
\label{c4}

Uno de los objetivos de este trabajo consiste en realizar una implementación que involucre
varios \ccc~funcionales del dominio para estudiar las interacciones entre los mismos
y proponer mecanismos para su resolución.\newline
En el presente capítulo se describen detalles de la implementación del \textit{software}
de una \sm~ realizada utilizando \textit{AspectJ}.

Los \textit{base} y \ccc~ son los que se identificaron en el capítulo anterior.\newline
A continuación se presentan detalles de diseño, sobre los objetos y aspectos que componen cada \cn.
En el apéndice A se puede encontrar el detalle completo del modelo de objetos desarrollado.

\begin{description}
\item[Notación utilizada]
Los gráficos presentados en este capítulo están realizados en una variación del diagrama de clases UML.
La figura \ref{fig:impl:notation} muestra un ejemplo de esta notación, donde:
\end{description}
\begin{itemize}
 \item Un \cn~ es representado por un \textit{package}.%rectángulo con una solapa que contiene el nombre del mismo. 
 \item Una aspecto es representado por un rectángulo que contiene el estereotipo <<aspect>> y el nombre del mismo en su interior.
 \item Una relación de \textit{crosscuts} es representada por una línea punteada desde el aspecto hacia el elemento afectado.
\end{itemize}

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/notation.eps}
\caption{Ejemplo de la notación utilizada.}
\label{fig:impl:notation}
\end{figure}
\FloatBarrier

\section{Game}
\game~ es un \cn~ funcional que no atraviesa otros \textit{concerns} del dominio.
La figura \ref{fig:impl:game} 	
muestra las clases de este \cn, el cual implementa la funcionalidad principal de un juego de apuestas.

Las clases principales de este \cn~son: \texttt{Game}, \texttt{ReelsManager} y \texttt{BetManager}.
Una instancia de la clase \texttt{Game} tiene créditos que se utilizan para
realizar apuestas. Las mismas son administradas por un objeto \texttt{BetManager},
que puede calcular el costo de cada jugada. Este objeto además, tiene la capacidad de
determinar los créditos ganados en cada juego. 
Este \cn~ también cuenta con un objeto \texttt{ReelsManager}, que implementa por ejemplo, el sorteo
de los símbolos de cada \textit{reel} para una jugada.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/game.eps}
\caption{Clases del \cn~ \game.}
\label{fig:impl:game}
\end{figure}

\clearpage
El siguiente fragmento de código muestra como interactúan estos objetos en el método \texttt{play()} de la clase \texttt{Game}. 
Previo a invocar el método \texttt{ReelsManager.spin()} para girar los \textit{reels}, se delega
en el objeto \texttt{BetManager} el cálculo del costo de la jugada (línea 5). Luego con los símbolos sorteados,
obtenidos del \texttt{ReelsManager}, el manejador de apuestas controla si hubo líneas ganadoras.

\begin{lstlisting}[label=fig:impl:cod:game,caption={Método \texttt{play()} de la clase \texttt{Game}.}]
public class Game {
  ...
  public boolean play() {
      ...
      if ( subtractCredits( _betManager.playCost() ) )
      {
	  _reelsManager.spin();
	  won = _betManager.checkWon(_reelsManager.getCurrentSymbols() );
	  ...
      }
      ...
    }
}
\end{lstlisting}

\section{HAL}
En este \cn~ se encuentran representados los dispositivos físicos con los que cuenta una \sm. 
En el diseño obtenido no existen aspectos dentro de este \cn~ y la interacción
con los dispositivos se produce a través de una instancia de la clase \texttt{HAL},
cuya interfaz se puede ver en la figura \ref{fig:impl:hal}.
El detalle del resto de las clases de este \cn~ se presenta en el Apéndice A.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/hal.eps}
\caption{\textit{API} de la clase \texttt{HAL}.}
\label{fig:impl:hal}
\end{figure}

En la implementación desarrollada un objeto de la clase \texttt{HAL} permite la interacción 
con pulsadores, detectar la apertura de la puerta del gabinete, cambiar el estado del \textit{switch} 
de \textit{demo}, guardar y obtener datos de una memoria no volátil.
%\textit{NVRAM}\footnote{Tipo de memoria
%de acceso aleatorio que no pierde la información almacenada al cortar la alimentación eléctrica.}.

\sloppy
Además de la clase \texttt{HAL} y las clases que representan los dipositivos,
este \cn~ define la interfaz \texttt{IHALSignalHandler}.
Instancias de clases que implementen esta interfaz, se pueden registrar como 
\textit{listeners} utilizando el método \texttt{registerHandler(IHALSignalHandler aHandler)}. \newline
De esta manera, cuando un dipositivo envía a la \texttt{HAL} una \textit{signal} determinada, se procede a notificar de la misma
a todos los \textit{listeners} registrados, como se puede ver en el fragmento de código \ref{fig:impl:cod:hal}.

\FloatBarrier
\begin{lstlisting}[label=fig:impl:cod:hal,caption={Método \texttt{dispatchSignal()} de la clase \texttt{HAL}.}]
public class HAL {
  ...
  public void dispatchSignal(HALSignal signal) {
      for(IHALSignalHandler handler : _signalsHandlers){
	  handler.process( signal );
      }
  }
}
\end{lstlisting}


\section{Meters}
\label{impl:meters}
El requerimiento principal de este \cn~ es mantener actualizada una colección de contadores.
Para esto se utiliza una jerarquía de aspectos, realizada en pro de una mejor modularización de los \textit{advices}. \newline
El aspecto de base \texttt{MetersAspect} tiene una referencia a un objeto \texttt{MetersManager}.
Este objeto cuenta con una colección para almacenar los valores de los \textit{meters}.\newline
El aspecto \texttt{MetersAspect}, provee de métodos que son heredados y usados por los subaspectos.
Estos métodos permiten obtener o modificar los valores almacenados del objeto \texttt{MetersManager}.
Un ejemplo de esto, es el método \texttt{setMeter()}, cuya definición se muestra en el fragmento de código \ref{fig:impl:cod:meters1},
el cual asocia un valor a un \textit{meter}.

\clearpage
\begin{lstlisting}[label=fig:impl:cod:meters1,caption={Método \texttt{setMeter()} del aspecto \texttt{MetersAspect}.}]
public abstract aspect MetersAspect {
  ...
  protected void setMeter(Meter meter, int value) {
      metersManager().setMeter(meter, value);
  }
}
\end{lstlisting}

En esta subclasificación, cada subaspecto define \textit{pointcuts} que atraviesan distintas clases.
Los puntos de interés de dichos \textit{advices}, son los métodos indicados en la figura \ref{fig:impl:meters}, en donde el valor de un \textit{meter} es leído o modificado.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/meters.eps}
\caption{Clases y aspectos del \cn~ de \meters.}
\label{fig:impl:meters}
\end{figure}

El fragmento de código \ref{fig:impl:cod:meters2}, muestra como se captura la modificación de las líneas seleccionadas durante una apuesta
mediante un \textit{after advice}. Utilizando el método heredado \texttt{setMeter()}, se actualiza el valor asociado
al meter \texttt{LINES}, en el objeto \texttt{MetersManager}. 

\begin{lstlisting}[label=fig:impl:cod:meters2,caption={\textit{After advice} sobre el \textit{pointcut} \texttt{BetManager.setLines()}.}]
public aspect MBetManager extends MetersAspect {
  ...
  after(int lines) : args (lines) && 
		     BetManager.setLines(int){
      setMeter(Meter.LINES, lines);
  }
}	
\end{lstlisting}

\section{Program Resumption}
\label{impl:resump}
La responsabilidad del \cn~ de \resump~ consiste en persistir ciertos datos de la \sm, por ejemplo los valores de los \textit{meters}.
Para esto se utiliza una jerarquía de aspectos, como muestra la figura \ref{fig:impl:resump}. Estos aspectos
también restauran el estado de la \sm~durante el inicio del sistema.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/resumption.eps}
\caption{Clases y aspectos del \cn~ de \resump.}
\label{fig:impl:resump}
\end{figure}
\FloatBarrier

Los subaspectos utilizan métodos que el aspecto \texttt{ProgramResumptionAspect} provee,
para obtener y guardar datos. La implementación de estos métodos, usa los servicios provistos por la \textit{HAL},
para almacenar y recuperar datos de la memoria no volátil.

El listado \ref{fig:impl:cod:resump} muestra parte del código del aspecto \texttt{Meters}. En las l\'ineas 3 a 5 se define
el \textit{pointcut} que captura la actualizaci\'on de un \textit{meter}. Luego en las l\'ineas 7 a 11, se define
el \textit{after advice}, que en la l\'inea 10 persiste el cambio utilizando el método heredado.

\begin{lstlisting}[label=fig:impl:cod:resump,caption={\textit{After advice} utilizado para persistir los \textit{meters}.}]
public aspect PRMeters extends ProgramResumption {
  ...
  pointcut setMeter(Meter meter, int value) : 
      args(meter, value) &&
      execution(void MetersManager.setMeter(Meter, int));

  after(Meter meter, int value) returning() :
      args(meter, value) && setMeter(Meter, int)
  {
      save(meter.toString(), String.valueOf(value));
  }
}
\end{lstlisting}

\section{Game Recall}
La responsabilidad de este \cn~ consiste en guardar los datos relevantes de,
al menos, los últimos 10 juegos, tal como indican las regulaciones. Los módulos principales, como se puede ver en la figura \ref{fig:impl:recall}, son: un
aspecto que afecta la clase \texttt{Game} y un objeto \texttt{GameRecallManager} que mantiene una colección de objetos 
\texttt{GameRecall}.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/recall.eps}
\caption{Clase y aspectos del \cn~\textit{Game Recall}.}
\label{fig:impl:recall}
\end{figure}
\FloatBarrier

El \textit{join point} de interés del aspecto \texttt{GameRecallAspect}, es el método \texttt{play} en el objeto \texttt{Game}. 
Como se puede ver en el fragmento de código \ref{fig:impl:cod:gr}, antes del sorteo que determina
la nueva posición de los \textit{reels}, el \textit{advice} asociado
guarda parte del estado de la \sm~ en un objeto \texttt{GameRecall}. 

\begin{lstlisting}[label=fig:impl:cod:gr,caption={Implementación del aspecto \texttt{GameRecallAspect}.}]
before() : execution(boolean Game.play(..)) 
{
  concerns.game.Game game = concerns.game.Game.get();
  _gc = new GameRecall();
  _gc.setBet(game.getBetManager().getBetPerLine());
  _gc.setLines(game.getBetManager().getPaylines());
  _gc.setPlayCost(game.getBetManager().playCost());
  _gc.setCredits(game.getCredits());
  _gc.setDate(game.getTime());
}
\end{lstlisting}

De manera similar al finalizar la jugada, mediante un \textit{after advice}, se completan los datos en el objeto \texttt{GameRecall}. Este \textit{advice} guarda
las posiciones de los \textit{reels} y los créditos ganados. Luego el objeto \texttt{GameRecall} 
es agregado a la colección del objeto \texttt{GameRecallManager}.
   
\section{Errors Conditions}
El \cn~ de \errors~ implementa el tratamiento de diferentes eventos de acuerdo a las regulaciones.
Por ejemplo, cuando se detecta la condición de \textit{door open}, se debe bloquear la \textit{UI} del juego y los dispositivos
de entrada, además de encender la \textit{tower lamp} para indicar que se requiere la presencia de un asistente.

La figura \ref{fig:impl:ec1} muestra las clases involucradas en este \cn. 
Una \textit{error condition} cuenta con un conjunto de acciones, 
las cuales deben aplicarse cuando la misma ocurre. A su vez, dichas acciones deben deshacerse cuando la
\textit{error condition} desaparece. 

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/errors.eps}
\caption{Clases del \cn~ de \error.}
\label{fig:impl:ec1}
\end{figure}

Este \cn~ además, cuenta con un aspecto cuya implementación se muestra en el fragmento de código \ref{fig:impl:cod:ec2}. Dicho
aspecto, utiliza un \textit{before advice} que está asociado al inicio del \textit{software} de la \sm. En el mismo, 
una instancia de la clase \texttt{HALSignalHandler}, se agrega como \textit{listener} en la \texttt{HAL}.

\begin{lstlisting}[label=fig:impl:cod:ec2,caption={Registro de un \textit{listener} en la \texttt{HAL}.}]
public aspect ErrorConditionsAspect {
  before() : execution(* Game.init()) {
      HAL.get().addHandler(new HALSignalHandler());
  }
}
\end{lstlisting}

\FloatBarrier

El \textit{handler} creado por el aspecto es notificado cuando una \textit{signal} ocurre. Este \textit{handler} crea en caso de ser necesario, una \texttt{ErrorCondition} para su tratamiento.
El fragmento de código \ref{fig:impl:cod:ec3} muestra parte de la implementación de la clase \texttt{HALSignalHandler}. 
El método \texttt{process(HALSignal)}, evalúa en un \textit{switch} la \textit{error condition} recibida. Esto es posible dado que la misma pertenece a un tipo enumerativo.
En cada rama del \textit{switch}, líneas 5 a 10, se definen las señales a las cuales debe asociarse una \textit{error condition}. La misma es creada y sus acciones son aplicadas según el caso.

\clearpage
\begin{lstlisting}[label=fig:impl:cod:ec3,caption={Creación de la \textit{error condition} \texttt{DoorOpen}.}]
public class HALSignalHandler implements IHALSignalHandler 
{
  @Override
  public void process(HALSignal signal) {
      switch (signal) {
	  case MAIN_DOOR_OPEN:
	      new DoorOpen().applyActions();
	      break;
	  case MAIN_DOOR_CLOSE:
	  ...
  }
}
\end{lstlisting}

\section{G2S y PCP}
\label{c4.comm}
Estos \cn s encapsulan el comportamiento de los protocolos de comunicaci\'on, además de su interacción con la \sm. 
Un protocolo permite que la \sm~reporte información y reciba comandos. La ocurrencia de determinados eventos, debe ser reportada a 
los sistemas de monitoreo. Un ejemplo de esto, es el comienzo de un juego, indicado por el evento \textit{Begin Game}.
Por otro lado, una \sm~puede recibir comandos, los cuales pueden consultar un valor como es el caso del comando \textit{GetMeter} o alterar el estado de la \sm, como 
lo hace el comando \textit{SetTime}.
% Como es posible utilizar más de un protocolo de comunicación a la vez, si no se maneja adecuadamente el arribo de los comandos que modifican el estado de la \sm,
% se pueden generar inconsistencias.
En la figura \ref{fig:impl:comm1} se pueden ver las clases involucradas en este \cn.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/protocols.eps}
\caption{Clases de los \textit{concerns G2S} y \textit{PCP}.}
\label{fig:impl:comm1}
\end{figure}

Cada comando que puede ser recibido por una \sm~ implementa la interfaz \texttt{ProtocolCmd}.
La misma define el método \texttt{execute()}, el cual contiene el comportamiento asociado al comando.
Un ejemplo de esto es la clase \texttt{SetTime}, que tiene como acción asociada modificar la hora de la \sm.

En esta implementación, la jerarquía de comandos es compartida por ambos protocolos. 
Esto se debe a que los protocolos brindan la misma funcionalidad. Los protocolos solo difieren en la forma en que los mensajes son serealizados o los 
intervalos de tiempo utilizados para el intercambio de mensajes.

En este \cn~existe una jerarquía de aspectos que se ve en la figura \ref{fig:impl:comm2}. 
Estos aspectos son utilizados para capturar eventos ocurridos en otros \cns, por ejemplo el inicio de un juego en la clase \texttt{Game}.\newline
El aspecto de base, define los \textit{pointcuts} de interés para los protocolos. Cada subaspecto
implementa los \textit{advices} correspondientes, con el objetivo de notificar a los
sistemas de monitoreo en tiempo real, de los cambios en la \sm.

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/protocols2.eps}
\caption{Jerarquía de aspectos utilizada para notificar cambios en la \sm.}
\label{fig:impl:comm2}
\end{figure}

El fragmento de código \ref{fig:impl:cod:comm2}, muestra el \textit{before advice} del aspecto \texttt{PCPAspect}, que
notifica del comienzo de una jugada a los sistemas de monitoreo. Para esto utiliza el método heredado \texttt{send()}.

\begin{lstlisting}[label=fig:impl:cod:comm2,caption={Notificación del evento \textit{Begin Game} en el protocolo \textit{PCP}.}]
public aspect PCPAspect extends CommProtocolAspect
{
  ...
  before() : Game.play() 
  {
      send( new BeginGameEvent() );
  }
}
\end{lstlisting}

\section{Demo}
\label{impl:demo}

La funcionalidad principal de este \cn~ es poder seleccionar que premio ganar en la próxima jugada.
Esto requiere alterar el comportamiento del \textit{core} de la \sm~para permitir seleccionar
el premio otorgado por el juego, para esto se debe afectar la forma en la que se determina la posici\'on
de los \textit{reels}. 
Por esto, el \cn~ de \textit{Demo} afecta al \cn~ de \textit{Game}, como se puede ver en la figura \ref{fig:impl:demo}. 

\begin{figure}[ht!]
\centering
\includegraphics[scale=0.60]{img/4/demo.eps}
\caption{El aspecto \texttt{Demo} afecta al objeto \texttt{ReelsManager}.}
\label{fig:impl:demo}
\end{figure}

En el aspecto \texttt{Demo}, la ejecución del método \textit{ReelsManager.spin()} es 
capturada por un \textit{around advice}, para alterar el sorteo de las posiciones de los \textit{reels}.
Cuando el modo \textit{demo} se encuentra activo,
se fuerza la salida de un determinado \textit{outcome} y en caso contrario se procede con la ejecución normal del método.

Dado que el proceso de \textit{weaving} se realiza en tiempo de compilación y el aspecto \texttt{Demo} está siempre presente,
el mismo mantiene en una variable su estado de activaci\'on.
Esta variable cambia de valor según el estado del \textit{switch} de \textit{demo} en la \texttt{HAL}. Para la actualización de la misma
se cuenta con dos \textit{advices} sobre la clase \texttt{HAL}, uno sobre el 
\textit{pointcut} \texttt{demoSwitchOn()} y otro sobre \texttt{demoSwitchOff()}.

\begin{lstlisting}[label=fig:impl:cod:demo1,caption={\textit{Advices} utilizados para modificar el estado del modo \textit{demo}.}]
public aspect Demo {
  private boolean _on = false;
  ...
  after() returning(): execution(void HAL.demoSwitchOn()) 
  {
      _on = true; 
  }
  after() returning(): execution(void HAL.demoSwitchOff()) 
  {
      _on = false; 
  }
}	
\end{lstlisting}

\clearpage
La implementación de esta funcionalidad se puede ver en el fragmento de código \ref{fig:impl:cod:demo2}.
La variable \texttt{\_outcome} contiene las posiciones de los \textit{reels} que permiten ganar el premio seleccionado por el usuario
mediante la \textit{UI} de la \sm. Mediante el \textit{around advice} se evita la ejecución del método 
\texttt{ReelsManager.spin()} y se altera la posición de cada uno de los \textit{reels}.

\begin{lstlisting}[label=fig:impl:cod:demo2,caption={\textit{Advice} utilizado para forzar un \textit{outcome} en modo \textit{demo}.}]
void around() : execution(void ReelsManager.spin())
{
  if (_on) {
      ArrayList<Reel> reels = Game.get().getReelsManager()      
					.getReels();
      for (int i = 0; i < reels.size(); i++) {
	  reels.get(i).setOffset( _outcome[i] );
      }
  } else {
      proceed();
  }
}
\end{lstlisting}

% \clearpage
% \section{Resumen del capítulo}
% En este capítulo se describieron detalles de diseño de la implementación
% realizada utilizando \textbf{Java} y \textbf{AspectJ} de los \cns:
% \begin{itemize}
%  \item Game 
%  \item Meters
%  \item HAL
%  \item Program Resumption
%  \item Game Recall
%  \item Communication Protocol
%  \item Demo
%  \item Error Conditions
% \end{itemize}
% 
% De estos \cns, se describieron brevemente las clases y aspectos involucrados.
% En el siguiente capítulo se presentan a nivel implementación 
% las interacciones según la clasificación de Sanen~\etal~\cite{Sanen06} y se detallan los mecanismos desarrollados 
% para el tratamiento de las mismas.

\ifx\all\undefined
\end{document}
\fi