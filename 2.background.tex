\ifx\all\undefined
\include{0.base}
\begin{document}
\fi
\chapter{Programación Orientada a Aspectos e Interacciones entre Aspectos}
\chaptermark{AOP e Interacciones entre Aspectos}

En este capítulo se detallan los conceptos más importantes de la Programación Orientada a Aspectos (\textit{AOP})~\cite{KiczalesLMMLLI97}.
Este enfoque para la programcaci\'on,  permite la modularización de \textit{crosscutting concerns},
para lo cual introduce al aspecto como una unidad para representarlos.

La separación de \textit{crosscutting concerns} requiere que los aspectos interactúen,
de modo de lograr la funcionalidad final esperada. Sanen~\etal~\cite{Sanen06} proponen una 
clasificación para estas interacciones. Las categorías de la misma se describen, dado que serán utilizadas
para clasificar las interacciones halladas en el dominio de las \sm.

Por último, se introducen las caracaterísticas más relevantes de \textit{AspectJ}~\cite{aspectJ}, extensión para
\textit{AOP} del lenguaje \textit{Java}. La misma fue utilizada en la implementación del \textit{software}
de una \sm, realizada para el estudio concreto de las interacciones.

\section{Programación Orientada a Aspectos}

Una aplicación orientada a objetos, se estructura en función de objetos que colaboran.
Una de las mayores ventajas de la orientación a objetos, es que un sistema de \textit{software} 
puede ser construido con una colección de clases, donde cada una tiene responsabilidades que están claramente definidas. 

Sin embargo, existen funcionalidades de un sistema cuya implementación no puede ser modularizada y por lo tanto 
su implementación se encuentra distribuida en diferentes clases, lo que se denomina \textit{crosscutting concern}.

Ejemplos de \ccc~ no funcionales son: la funcionalidad de \textit{logging}, 
\textit{manejo de excepciones}, persistencia o inyección de código utilizado para análisis de rendimiento (\textit{profiling}), etc.
Estos \ccc, entre otros, fueron reportados por \textit{Rashid} \etal~\cite{ieee-2010} en el estudio sobre el uso de aspectos en la industria.

Estos \textit{concerns} no pueden ser encapsulados de forma adecuada~\cite{KiczalesLMMLLI97}, por la tanto
traen aparejados efectos negativos en el código fuente.\newline
Uno de ellos es tener la implementación de cierta propiedad distribuida. 
Este problema se conoce como \textit{scattered code} o código disperso.\newline
Otro problema asociado, consiste en que un mismo módulo no sólo implemente 
el comportamiento referido a su responsabilidad, sino también otros  comportamientos extrínsecos correspondientes a los \ccc. 
Esto se conoce como \textit{tangled code} o código enmarañado.

Con el objetivo de tratar estos problemas, nace la Programación Orientada a Aspectos, presentada por 
\textit{Kiczales} \etal~\cite{KiczalesLMMLLI97} en 1997. 
La misma obtuvo rápidamente la atención de la comunidad científica,
siendo señalada por el \textit{MIT} en el año 2001, como una de las tecnologías claves
de la próxima década~\cite{mit}.\newline
Este enfoque pretende ser una solución al problema de encapsular \textit{crosscutting concerns}, mediante
módulos denominados aspectos.

La implementación de un aspecto, incluye el comportamiento del \textit{crosscutting concern} y la
especificaci\'on de los lugares en donde será ejecutado dicho código.\newline 
Un \textit{join point} es un punto bien definido en la ejecución de un programa, por ejemplo:
la llamada a un método, la asignación de una variable o el lanzamiento de una excepción.

Los aspectos se componen de \textit{pointcuts} y \textit{advices}. 
Un \textit{pointcut} define un predicado sobre los \textit{join points}.
Por ejemplo, todas las llamadas al método \textit{m} en el objeto \textit{A}.\newline
Un \textit{advice} es equivalente a un método en \textit{OOP}, contiene el comportamiento que implementa el 
\textit{crosscutting concern}.
Un \textit{advice} es asociado a un \textit{pointcut}. De esta manera, cuando en tiempo de ejecución 
un \textit{join point} es capturado por un \textit{pointcut}, el código del \textit{advice} asociado es ejecutado.

Un \textit{advice} puede ser definido para ser ejecutado antes, después
o alrededor del \textit{join point} seleccionado. 
En un \textit{advice} que es ejecutado luego de la llamada de un método, es posible
obtener el valor de retorno del mismo. Por otro lado, en un \textit{advice} definido alrededor de un
\textit{join point}, el programador tiene la posibilidad de decidir si se ejecuta o no el \textit{join point}
capturado.

En algunos casos, para implementar un \textit{crosscutting concern} de manera efectiva, puede ser necesario alterar la estructura estática del programa. 
\textit{AOP} provee de un mecanismo denominado \textit{inter-type declarations}, que permite afectar la estructura de las clases. De esta manera,
es posible desde un aspecto añadir métodos y atributos a clases ya existentes.

Definidos los aspectos, la composición de los mismos con el código de la aplicación,
se realiza en un proceso denominado \textit{weaving}.
Aunque existen similitudes entre los lenguajes de AOP, una diferencia escencial reside 
en el momento en que se realiza este proceso. Esto puede ocurrir
en tiempo de compilación o en tiempo de ejecución, lo que da lugar a la clasificación de lenguajes estáticos o dinámicos.

\section{Interacciones entre aspectos}

La orientación a aspectos es aceptada 
como un mecanismo efectivo para la separación de \textit{crosscutting concerns}~\cite{Kiczales97}. 
Esto se debe, entre otras cosas, al grado de expresividad que este enfoque brinda al programador.\newline
Sin embargo, la característica de \textit{obliviousness} entre aspectos~\cite{filman:aosdbook05} donde el programa base desconoce
la existencia de los aspectos, hace que el comportamiento del sistema sea mucho más difícil de comprender.
 
Debido al hecho de que los aspectos afectan varios elementos de la aplicación,
es probable que los mismos interfieran entre sí de alguna manera. 
Esto da lugar a que se produzcan interacciones entre los aspectos, necesarias para lograr la funcionalidad final esperada.

En algunos casos, las interacciones son deseables, y su presencia debe ser asegurada. Este es el caso 
de dependencias entre aspectos, donde un aspecto requiere de otro para funcionar. \newline
En cambio en otros casos, si existen aspectos cuyo comportamiento es incopatible, es necesario evitar que la interacción se produzca.

\subsection{Taxonomía de las interacciones}

En el reporte técnico de \textit{AOSD-Europe} sobre \textit{Aspects Interactions}~\cite{Sanen06}, 
los autores clasifican las mismas en las siguientes categorías:
\textit{dependency}, \textit{conflict}, \textit{mutex} y \textit{reinforcement}. 

\textbf{Dependency:} esta forma de interacción cubre las situaciones donde un aspecto \textit{A}, depende de otro aspecto, \textit{B}.
En una situación de dependencia, si el aspecto \textit{B} no se encuentra presente, el aspecto \textit{A} no puede funcionar de manera correcta.

\textbf{Conflict:} la interacción de tipo \textit{Conflict} captura las situaciones donde se producen interferencias semánticas entre aspectos. 
Dos aspectos, \textit{A} y \textit{B}, pueden funcionar correctamente si no se encuentran presentes al mismo tiempo.
La presencia de ambos, puede generar errores o comportamientos no deseados en la aplicación.

\textbf{Mutex:} esta forma de interacción, trata la exclusión mútua entre aspectos que proveen la misma funcionalidad.
Al no ser aspectos complementarios, uno puede usarse, el otro no.

% \clearpage
\textbf{Reinforcement:} es un tipo de interacción positiva, se produce cuando la presencia de un aspecto \textit{A}, influye positivamente sobre otro, \textit{B}.
El aspecto \textit{A} puede funcionar sin la presencia de \textit{B}, pero de estar este último presente, \textit{A} brinda funcionalidad extendida.

Esta taxonomía que describe las formas en que los aspectos interactúan, es utilizada en el capítulo 5 del 
presente trabajo, para clasificar las relaciones entre los \textit{concerns} del dominio de las \textit{SM}.

\section{AspectJ}

\textit{AOP} no está ligada a un único lenguaje o paradigma de programación. 
Hoy en día existen varias extensiones de AOP~\cite{phantom, aspectJ, aspectcplusplus}
para diferentes lenguajes de programación~\cite{PharoByExample, Flanagan:2008:RPL:1408408,
Hejlsberg:2003:CLS:861332}. 
Entre las mismas, se encuentra la implementación pionera: \textit{AspectJ}~\cite{aspectJ},
extensión para \textit{AOP} del lenguaje Java~\cite{gosling05java-langspec-3}. 

\textit{AspectJ} es el lenguaje de aspectos con mayor influencia y es el punto de referencia para otros lenguajes.
Fue creado por un equipo de \textit{Xerox PARC}~\cite{xerox:aspectjxx}, liderado por \textit{Gregor Kiczales}, en el año 1997.
Desde entonces, ha acompañado la evolución del lenguaje \textit{JAVA}. 

 \textit{AspectJ} ha sido utilizado en la industria, prueba de esto es que forma 
 parte del \textit{framework} \textit{Spring}~\cite{spring}.\newline
La herramienta m\'as popular para la programaci\'on con \textit{AspectJ} es el \textit{plug-in} \textit{AJDT}~\cite{eclipse:ajdt} para el \textit{IDE} \textit{Eclipse}~\cite{eclipse:webxx}.
El mismo ofrece un conjunto de sólidas herramientas, que facilitan el desarrollo de aplicaciones orientadas a aspectos
  
\subsection{Sintaxis}
\textit{AspectJ} provee al usuario programador de una notación para definir aspectos, \textit{pointcuts}, \textit{advices} y \textit{inter-type declarations}.
A continuación se realiza una breve descripción de la sintaxis de esta extensión. Para mayor detalle se puede ver la guía de programación en línea de 
\textit{AspectJ}~\cite{aspectj:doc}.

\subsubsection{Pointcuts}
Los \textit{pointcuts} pueden ser declarados en un aspecto, clase o interface. Como en 
las variables y métodos de \textit{Java}, en un \textit{pointcut} se puede especificar
su nivel de visibilidad: \textit{public}, \textit{protected}, etc. \newline
En \textit{AspectJ}, los \textit{pointcuts} pueden ser anónimos o nombrados.
Los anónimos son declarados en el lugar donde se usan, por ejemplo al definir un \textit{advice}.
En cambio, los \textit{pointcuts} nombrados son elementos reusables, dado que pueden ser referenciados de diferentes
lugares. La figura \ref{fig:bg1} detalla la sintaxis de los \textit{pointcuts} nombrados.

\begin{lstlisting}[label=fig:bg1,caption={Sintaxis de los \textit{pointcuts} nombrados.}]
[access specifier] pointcut pointcut_name([args]) :
                            pointcut_definition
\end{lstlisting}

A la izquierda de los ``:'' se encuentra el nombre del \textit{pointcut} y del lado 
derecho su definición. Aquí mediante un predicado, se identifican los \textit{join points}.

\sloppy{
En el fragmento de código \ref{fig:bg2}, se puede ver la definición de un \textit{pointcut}, denominado \texttt{accountOperations}. 
El mismo captura la ejecución de todos los métodos de una clase llamada \texttt{Account}.
}
\begin{lstlisting}[label=fig:bg2,caption={Ejemplo de definición de un \textit{pointcut} en \textit{AspectJ}.}]
protected pointcut accountOperations() : 
                   call(* Account.*(..))
\end{lstlisting}

\subsubsection{Advice}
Como fue explicado, cuando en tiempo de ejecución 
un \textit{join point} es capturado por un \textit{pointcut}, el código del \textit{advice} asociado es ejecutado.
A comparación de los \textit{pointcuts}, en \textit{AspectJ}
los \textit{advices} sólo pueden definirse de manera anónima.\newline
Para indicar el momento en que la funcionalidad del \textit{advice} deba ser ejecutada, \textit{AspectJ}
provee las palabras claves: \textit{before}, \textit{after} y \textit{around}. Mediante las mismas, se define
el tipo de un \textit{advice}. \newline 
La estructura de un \textit{advice} puede dividirse en tres partes: 
la declaración del tipo del \textit{advice}, la especificación del \textit{pointcut} y el cuerpo.

Utilizando el \textit{pointcut} \texttt{accountOperations()}, es posible definir un \textit{before advice} que imprime un mensaje
antes de la ejecución de cada método de la clase \texttt{Account}. Este ejemplo se puede ver en el fragmento de código \ref{fig:bg3}, donde se utiliza la variable \texttt{thisJoinPoint}, disponible 
en el cuerpo del \textit{advice}, la cual contiene información del \textit{jointpoint} capturado.

\begin{lstlisting}[label=fig:bg3,caption={Uso de un \textit{pointcut} nombrado en un \textit{before advice}.}]
before() : accountOperations() {
    System.out.println("Executing: " + thisJoinPoint);
}
\end{lstlisting}

\FloatBarrier
El ejemplo anterior, también puede definirse utilizando \textit{pointcuts} anónimos. En la figura \ref{fig:bg4},
dicho \textit{pointuct}, se define dentro de la estructura del propio \textit{advice}.

\begin{lstlisting}[label=fig:bg4,caption={Uso de un \textit{pointcut} anónimo en un \textit{before advice}.}]
before() : call(* Account.*(..)) { advice body }
\end{lstlisting}


En la declaración de un \textit{advice} es posible especificar que
información de contexto está disponible para ser utilizada en el cuerpo. Por ejemplo,
es posible acceder al objeto en ejecución sobre el cual el \textit{jointpoint} es capturado. \newline
En un \textit{around advice}, la manera de indicar que se proceda con la ejecución del método que 
ha sido capturado, es mediante el uso de la palabra clave \textit{proceed()}.

El fragmento de código \ref{fig:bg5}, define un \textit{around advice} sobre el método \texttt{Account.debit()}.
En la definición del \textit{advice} se especifican como parámetros: el objeto sobre el cual
se ejecuta el método y el parámetro que este recibe. De esta manera, el programador podría evaluar una condición,
para decidir si proceder o no con la ejecución del método.

\begin{lstlisting}[label=fig:bg5,caption={Ejemplo de definición de un \textit{around advice}.}]
void around(Account account, float amount)
     call(* Account.debit(float))
     && target(account)
     && args(amount)
{
    if( _debitCondition ) {
	proceed(account, amount);
    } 
}
\end{lstlisting}

\subsubsection{Aspecto} 
El constructor \texttt{aspect}, cuya sintaxis detalla la figura \ref{fig:bg6}, indica que el elemento que está siendo definido es un aspecto. 
Esta entidad tiene un nombre y una especificación de acceso. Los aspectos pueden ser abstractos, extender otros aspectos y también
implementar interfaces. El cuerpo de un aspecto contiene el código en el cual se definen, entre otros elementos: 
\textit{inter-type declarations}, \textit{pointcuts} y \textit{advices}. 

\begin{lstlisting}[label=fig:bg6,caption={Sintaxis de un aspecto.}]
[access specification] aspect <AspectName>
[extends class_or_aspect_name]
[implements interface_list] {
... aspect_body
}
\end{lstlisting}

El fragmento de código \ref{fig:bg7} define un aspecto \texttt{AccountLogging}, que herada de \texttt{AbstractLogging}. El cuerpo
de este aspecto define los elementos previamente detallados.

\begin{lstlisting}[label=fig:bg7,caption={Ejemplo de un aspecto que define un \textit{pointcut} y un \textit{advice}.}]
public aspect AccountLogging extends AbstractLogging {

  protected pointcut accountOperations() : 
		     call(* Account.*(..))
		  
  before() : accountOperations() {
      System.out.println("Executing: " + thisJoinPoint);
  }
}
\end{lstlisting}

\subsubsection{Inter-type declarations}
Mediante el uso de \textit{pointcuts} y \textit{advices} es posible modificar el comportamiento dinámico de un sistema. 
Para afectar la estructura estática del mismo, \textit{AspectJ} provee de un mecanismo denominado \textit{Introduction}.
Este mecanismo permite alterar la estructura de clases, interfaces y otros aspectos. 

Un ejemplo de uso de \textit{Introduction} se puede ver en el fragmento de código \ref{fig:bg8}. 
El aspeto declarado agrega a la clase \texttt{Account}, una variable en la l\'inea 3 y un método en las l\'ineas 5 a 7. Ambos componentes se definen
de la misma manera que en una clase \textit{Java}, con la única diferencia que se antepone el nombre de la clase destino.

\begin{lstlisting}[label=fig:bg8,caption={Definición de una variable y un método mediante \textit{Introduction}.}]
public aspect AccountOperationsAspect {

  private int Account._varName;

  public int Account.getVarName() {
      return _varName;
  }
}
\end{lstlisting}

\FloatBarrier

\subsubsection{Weaving}
En el compilador de \textit{AspectJ}, la fase de \textit{weaving} puede ser ejecutada en tres momentos diferentes:
\begin{itemize}
\item \textit{Compile-time weaving}: es la forma utilizada cuando se dispone del código fuente de las aplicación.
\item \textit{Post-compile weaving}: es utilizado para realizar el proceso de \textit{weaving} sobre archivos \textit{.class} o archivos \textit{JAR}.
\item \textit{Load-time weaving}: el proceso de \textit{weaving} se produce en el momento en que un archivo \textit{.class} es cargado en la \textit{JVM}. Para poder ser utilizado
este modo, el \textit{run-time environment} debe proveer de \textit{weaving class loaders}.
\end{itemize}
% 
% \section{Resumen del capítulo}
% En este capítulo se explicaron varios conceptos de la \textit{Programación Orientada a Aspectos}, entre los cuales se detallaron
% los aspectos, \textit{join points}, \textit{pointcuts} y \textit{advices}, entre otros.
% 
% Luego se presentó la clasificación que propone Sanen~\etal, para las interacciones entre aspectos. Se describieron las categorías
% \textit{Mutex}, \textit{Conflict}, \textit{Dependency} y \textit{Reinforcement}.
% 
% Por último, dado que la implementación sobre la que se realizaron los estudios utiliza 
% el lenguaje \textit{Java}, la extensión \textit{AspectJ} fue descripta. De la misma se listaron
% sus características más relevantes y se presentaron ejemplos de uso.


\ifx\all\undefined
\end{document}
\fi